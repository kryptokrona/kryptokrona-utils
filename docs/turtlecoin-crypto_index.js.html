<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: turtlecoin-crypto/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: turtlecoin-crypto/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Copyright (c) 2019, The TurtleCoin Developers
//
// Please see the included LICENSE file for more information.

/* eslint camelcase: 0 */

'use strict'

/**
 * Module of TurtleCoin Cryptographic Methods
 * @module Crypto
 * @class
 */
class Crypto {
  constructor () {
    /**
     * Whether the module is using native JS or WASM methods
     * @type {boolean}
     * @readonly
     */
    this.isNative = false

    /**
     * What type of underlying cryptographic library is being used
     * @type {string}
     * @readonly
     */
    this.type = 'unloaded'

    this.crypto = loadNativeAddon()

    if (this.crypto) {
      this.type = 'c++'
    }

    if (!this.crypto &amp;&amp; typeof window !== 'undefined' &amp;&amp; typeof window.TurtleCoinCrypto !== 'undefined') {
      this.crypto = loadBrowserWASM()

      if (this.crypto) {
        this.type = 'wasm'
        this.isNative = true
      }
    }

    if (!this.crypto &amp;&amp; typeof window !== 'undefined') {
    /* If the there isn't a TurtleCoinCrypto WASM module
       preloaded in the environment, then let's try to load
       the WASM ourselves */
      this.crypto = loadWASMJS()

      if (this.crypto) {
        this.type = 'wasmjs'
        this.isNative = true
      }
    }

    if (!this.crypto) {
      this.crypto = loadNativeJS()
      if (this.crypto) {
        this.type = 'js'
        this.isNative = true
      } else {
        throw new Error('Could not load a core cryptography module')
      }
    }
  }

  /**
   * Validates that the ring signatures provided are valid
   * @param {string} transactionPrefixHash - the transaction prefix hash
   * @param {string} keyImage - the key image that the signature pertains to
   * @param {string[]} inputKeys - the input keys used in the ring
   * @param {string[]} signatures - the signatures to verify
   * @returns {boolean} whether the signatures are valid or not
   */
  checkRingSignatures (transactionPrefixHash, keyImage, inputKeys, signatures) {
    if (!this.isNative) {
      return this.crypto.checkRingSignature(transactionPrefixHash, keyImage, inputKeys, signatures)
    } else {
      const cSigs = new this.crypto.VectorString()
      const cInputKeys = new this.crypto.VectorString()

      inputKeys.forEach((key) => {
        cInputKeys.push_back(key)
      })

      signatures.forEach((sig) => {
        cSigs.push_back(sig)
      })

      return this.crypto.checkRingSignature(transactionPrefixHash, keyImage, cInputKeys, cSigs)
    }
  }

  /**
   * CryptoNight Fast Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_fast_hash (data) {
    if (!this.isNative) {
      return this.crypto.cn_fast_hash(data)
    } else {
      const result = this.crypto.cn_fast_hash(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * Derives the public key from the specified parameters
   * @param {string} derivation - the derivation
   * @param {number} outputIndex - the output index in the transaction
   * @param {string} publicKey - the public key
   * @returns {string} the resulting public key
   */
  derivePublicKey (derivation, outputIndex, publicKey) {
    if (!this.isNative) {
      return this.crypto.derivePublicKey(derivation, outputIndex, publicKey)
    } else {
      var result

      try {
        result = this.crypto.derivePublicKey(derivation, outputIndex, publicKey)
      } catch (e) {
        result = e
        result = false
      }

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * Derives the secret key from the specified parameters
   * @param {string} derivation - the derivation
   * @param {number} outputIndex - the output index in the transaction
   * @param {string} secretKey - the secret key
   * @returns {string} the resulting secret key
   */
  deriveSecretKey (derivation, outputIndex, secretKey) {
    if (!this.isNative) {
      return this.crypto.deriveSecretKey(derivation, outputIndex, secretKey)
    } else {
      var result

      try {
        result = this.crypto.deriveSecretKey(derivation, outputIndex, secretKey)
      } catch (e) {
        result = e
        result = false
      }

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * Generates the key derivation of the given keys
   * @param {string} transactionPublicKey - the transaction public key
   * @param {string} privateViewKey - the private view key
   * @returns {string} the derivation
   */
  generateKeyDerivation (transactionPublicKey, privateViewKey) {
    if (!this.isNative) {
      return this.crypto.generateKeyDerivation(transactionPublicKey, privateViewKey)
    } else {
      var result

      try {
        result = this.crypto.generateKeyDerivation(transactionPublicKey, privateViewKey)
      } catch (e) {
        result = e
        result = false
      }

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * Generates the key  image from the given public and private keys
   * @param {string} publicKey - the public emphemeral
   * @param {string} privateKey - the private emphemeral
   * @returns {string} the key image
   */
  generateKeyImage (publicKey, privateKey) {
    if (!this.isNative) {
      return this.crypto.generateKeyImage(publicKey, privateKey)
    } else {
      var result

      try {
        result = this.crypto.generateKeyImage(publicKey, privateKey)
      } catch (e) {
        result = e
        result = false
      }

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * Generates the ring signatures for the supplied parameters
   * @param {string} transactionPrefixHash - the transaction prefix hash
   * @param {string} keyImage - the key image that the signature pertains to
   * @param {string[]} inputKeys - the input keys used in the ring
   * @param {string} privateKey - the real private key used for signing
   * @param {number} realIndex - the index of the real output in the inputKeys array
   * @returns {string[]} the resulting ring signatures
   */
  generateRingSignatures (transactionPrefixHash, keyImage, inputKeys, privateKey, realIndex) {
    if (!this.isNative) {
      return this.crypto.generateRingSignatures(transactionPrefixHash, keyImage, inputKeys, privateKey, realIndex)
    } else {
      var cSigs = new this.crypto.VectorString()
      const cInputKeys = new this.crypto.VectorString()

      inputKeys.forEach((key) => {
        cInputKeys.push_back(key)
      })

      try {
        cSigs = this.crypto.generateRingSignatures(transactionPrefixHash, keyImage, cInputKeys, privateKey, realIndex)
      } catch (e) {
        cSigs = e
        cSigs = false
      }

      if (!cSigs) return [true, null]

      const sigs = []

      for (var i = 0; i &lt; cSigs.size(); i++) {
        sigs.push(cSigs.get(i))
      }

      return [null, sigs]
    }
  }

  /**
   * scalar 32-bit reduction
   * @param {string} data - hexadecimal data to reduce
   * @returns {string} the reduction
   */
  scReduce32 (data) {
    if (!this.isNative) {
      return this.crypto.scReduce32(data)
    } else {
      const result = this.crypto.scReduce32(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * Generates the public key from the private key
   * @param {string} privateKey - the private key
   * @return {string} the public key
   */
  secretKeyToPublicKey (privateKey) {
    if (!this.isNative) {
      return this.crypto.secretKeyToPublicKey(privateKey)
    } else {
      var result

      try {
        result = this.crypto.secretKeyToPublicKey(privateKey)
      } catch (e) {
        result = e
        result = false
      }

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * Calculates the tree branch of the given hashes
   * @param {string[]} arr - the hashes to use in the calculation
   * @return {string[]} the resulting tree branches
   */
  tree_branch (arr) {
    if (!this.isNative) {
      return this.crypto.tree_branch(arr)
    } else {
      var branches = new this.crypto.VectorString()
      const hashes = new this.crypto.VectorString()

      arr.forEach((item) => {
        hashes.push_back(item)
      })

      try {
        branches = this.crypto.tree_branch(hashes)
      } catch (e) {
        branches = e
        branches = false
      }

      if (!branches) return [true, null]

      const results = []

      for (var i = 0; i &lt; branches.size(); i++) {
        results.push(branches.get(i))
      }

      return [null, results]
    }
  }

  /**
   * Calculates the tree depth of the given value
   * @param {number} count - the number of items
   * @returns {number} the depth of the tree
   */
  tree_depth (count) {
    if (!this.isNative) {
      return this.crypto.tree_depth(count)
    } else {
      const result = this.crypto.tree_depth(count)

      if (typeof result !== 'number') {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * Calculates the tree hash of the given hashes
   * @param {string[]} arr - the hashes to use in the calculation
   * @return {string} the resulting tree hash
   */
  tree_hash (arr) {
    if (!this.isNative) {
      return this.crypto.tree_hash(arr)
    } else {
      const hashes = new this.crypto.VectorString()

      arr.forEach((item) => {
        hashes.push_back(item)
      })

      const result = this.crypto.tree_hash(hashes)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * Calculates the tree hash of the given branches
   * @param {string[]} branches - the hashes of the branches to use in the calculation
   * @param {string} leaf - the leaf to include in the calculation
   * @param {number} path - the path to include in the calculation
   * @return {string} the resulting tree hash
   */
  tree_hash_from_branch (branches, leaf, path) {
    if (!this.isNative) {
      return this.crypto.tree_hash_from_branch(branches, leaf, path)
    } else {
      const _branches = new this.crypto.VectorString()

      branches.forEach((branch) => {
        _branches.push_back(branch)
      })

      const result = this.crypto.tree_hash_from_branch(_branches, leaf, path.toString())

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * Underives the public key from the given parameters
   * @param {string} derivation - the derivation
   * @param {number} outputIndex - the output index in the transaction
   * @param {string} outputKey - the output key
   * @returns {string} the public key
   */
  underivePublicKey (derivation, outputIndex, outputKey) {
    if (!this.isNative) {
      return this.crypto.underivePublicKey(derivation, outputIndex, outputKey)
    } else {
      var result

      try {
        result = this.crypto.underivePublicKey(derivation, outputIndex, outputKey)
      } catch (e) {
        result = e
        result = false
      }

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /* Hashing methods */

  /**
   * CryptoNight v0 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_slow_hash_v0 (data) {
    if (!this.isNative) {
      return this.crypto.cn_slow_hash_v0(data)
    } else {
      const result = this.crypto.cn_slow_hash_v0(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight v1 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_slow_hash_v1 (data) {
    if (!this.isNative) {
      return this.crypto.cn_slow_hash_v1(data)
    } else {
      const result = this.crypto.cn_slow_hash_v1(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight v2 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_slow_hash_v2 (data) {
    if (!this.isNative) {
      return this.crypto.cn_slow_hash_v2(data)
    } else {
      const result = this.crypto.cn_slow_hash_v2(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Lite v0 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_lite_slow_hash_v0 (data) {
    if (!this.isNative) {
      return this.crypto.cn_lite_slow_hash_v0(data)
    } else {
      const result = this.crypto.cn_lite_slow_hash_v0(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Lite v1 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_lite_slow_hash_v1 (data) {
    if (!this.isNative) {
      return this.crypto.cn_lite_slow_hash_v1(data)
    } else {
      const result = this.crypto.cn_lite_slow_hash_v1(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Lite v2 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_lite_slow_hash_v2 (data) {
    if (!this.isNative) {
      return this.crypto.cn_lite_slow_hash_v2(data)
    } else {
      const result = this.crypto.cn_lite_slow_hash_v2(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Dark v0 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_dark_slow_hash_v0 (data) {
    if (!this.isNative) {
      return this.crypto.cn_dark_slow_hash_v0(data)
    } else {
      const result = this.crypto.cn_dark_slow_hash_v0(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Dark v1 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_dark_slow_hash_v1 (data) {
    if (!this.isNative) {
      return this.crypto.cn_dark_slow_hash_v1(data)
    } else {
      const result = this.crypto.cn_dark_slow_hash_v1(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Dark v2 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_dark_slow_hash_v2 (data) {
    if (!this.isNative) {
      return this.crypto.cn_dark_slow_hash_v2(data)
    } else {
      const result = this.crypto.cn_dark_slow_hash_v2(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Dark Lite v0 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_dark_lite_slow_hash_v0 (data) {
    if (!this.isNative) {
      return this.crypto.cn_dark_lite_slow_hash_v0(data)
    } else {
      const result = this.crypto.cn_dark_lite_slow_hash_v0(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Dark Lite v1 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_dark_lite_slow_hash_v1 (data) {
    if (!this.isNative) {
      return this.crypto.cn_dark_lite_slow_hash_v1(data)
    } else {
      const result = this.crypto.cn_dark_lite_slow_hash_v1(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Dark Lite v2 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_dark_lite_slow_hash_v2 (data) {
    if (!this.isNative) {
      return this.crypto.cn_dark_lite_slow_hash_v2(data)
    } else {
      const result = this.crypto.cn_dark_lite_slow_hash_v2(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Turtle v0 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_turtle_slow_hash_v0 (data) {
    if (!this.isNative) {
      return this.crypto.cn_turtle_slow_hash_v0(data)
    } else {
      const result = this.crypto.cn_turtle_slow_hash_v0(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Turtle v1 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_turtle_slow_hash_v1 (data) {
    if (!this.isNative) {
      return this.crypto.cn_turtle_slow_hash_v1(data)
    } else {
      const result = this.crypto.cn_turtle_slow_hash_v1(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Turtle v2 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_turtle_slow_hash_v2 (data) {
    if (!this.isNative) {
      return this.crypto.cn_turtle_slow_hash_v2(data)
    } else {
      const result = this.crypto.cn_turtle_slow_hash_v2(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Turtle Lite v0 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_turtle_lite_slow_hash_v0 (data) {
    if (!this.isNative) {
      return this.crypto.cn_turtle_lite_slow_hash_v0(data)
    } else {
      const result = this.crypto.cn_turtle_lite_slow_hash_v0(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Turtle Lite v1 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_turtle_lite_slow_hash_v1 (data) {
    if (!this.isNative) {
      return this.crypto.cn_turtle_lite_slow_hash_v1(data)
    } else {
      const result = this.crypto.cn_turtle_lite_slow_hash_v1(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Turtle Lite v2 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  cn_turtle_lite_slow_hash_v2 (data) {
    if (!this.isNative) {
      return this.crypto.cn_turtle_lite_slow_hash_v2(data)
    } else {
      const result = this.crypto.cn_turtle_lite_slow_hash_v2(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Soft Shell v0 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @param {number} height - the height to use in the calculation
   * @returns {string} the resulting hash
   */
  cn_soft_shell_slow_hash_v0 (data, height) {
    if (!this.isNative) {
      return this.crypto.cn_soft_shell_slow_hash_v0(data, height)
    } else {
      const result = this.crypto.cn_soft_shell_slow_hash_v0(data, height)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Soft Shell v1 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @param {number} height - the height to use in the calculation
   * @returns {string} the resulting hash
   */
  cn_soft_shell_slow_hash_v1 (data, height) {
    if (!this.isNative) {
      return this.crypto.cn_soft_shell_slow_hash_v1(data, height)
    } else {
      const result = this.crypto.cn_soft_shell_slow_hash_v1(data, height)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * CryptoNight Soft Shell v2 Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @param {number} height - the height to use in the calculation
   * @returns {string} the resulting hash
   */
  cn_soft_shell_slow_hash_v2 (data, height) {
    if (!this.isNative) {
      return this.crypto.cn_soft_shell_slow_hash_v2(data, height)
    } else {
      const result = this.crypto.cn_soft_shell_slow_hash_v2(data, height)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }

  /**
   * Chukwa Slow Hash Method
   * @param {string} data - hexadecimal string to hash
   * @returns {string} the resulting hash
   */
  chukwa_slow_hash (data) {
    if (!this.isNative) {
      return this.crypto.chukwa_slow_hash(data)
    } else {
      const result = this.crypto.chukwa_slow_hash(data)

      if (!result) {
        return [true, null]
      } else {
        return [null, result]
      }
    }
  }
}

function loadNativeAddon () {
  var Self = false

  try {
    Self = require('turtlecoin-crypto')
    if (Object.getOwnPropertyNames(Self).length === 0) {
      throw new Error('Could not load')
    }
  } catch (e) {
    Self = e
    Self = false
  }

  return Self
}

function loadNativeJS () {
  var Self = false

  try {
    Self = require('./turtlecoin-crypto.js')()
    if (Object.getOwnPropertyNames(Self).length === 0) {
      throw new Error('Could not load')
    }
  } catch (e) {
    Self = e
    Self = false
  }

  return Self
}

function loadBrowserWASM () {
  var Self = false

  try {
    Self = window.TurtleCoinCrypto()
    if (Object.getOwnPropertyNames(Self).length === 0) {
      throw new Error('Could not load')
    }
  } catch (e) {
    Self = e
    Self = false
  }

  return Self
}

function loadWASMJS () {
  if (typeof window === 'undefined') return false

  var Self = false

  try {
    Self = require('./turtlecoin-crypto-wasm.js')()
    if (Object.getOwnPropertyNames(Self).length === 0) {
      throw new Error('Could not load')
    }
  } catch (e) {
    Self = e
    Self = false
  }

  return Self
}

module.exports = Crypto
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Externals</h3><ul><li><a href="external-Crypto.html">Crypto</a></li></ul><h3>Classes</h3><ul><li><a href="Block.html">Block</a></li><li><a href="BlockTemplate.html">BlockTemplate</a></li><li><a href="Crypto.html">Crypto</a></li><li><a href="CryptoNote.html">CryptoNote</a></li><li><a href="LevinPacket.html">LevinPacket</a></li><li><a href="Transaction.html">Transaction</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sun Sep 22 2019 13:17:26 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
